#!/bin/sh

# This scenario has the following object hierarchy:
#
#                   TA
#                    |
#           +--------+-------+
#           |                |
#       VictimCA          EvilCA
#           |                |
#      VictimChild     FakeVictimCA
#                            |
#                      FakeVictimCRL
#
# All objects are valid.  The FakeVictimCA cert has the same Subject
# as the VictimCA cert.  The CRL issued by FakeVictimCA lists the
# serial number of the VictimChild certificate.  The goal of this test
# is to see whether RPs treat VictimChild as revoked.
#
# Because file add order affects which code paths are exercised (e.g.,
# cert before CRL vs. CRL before cert), this test script tries a bunch
# of different sequences.  Trying all possible file add sequences
# would result in 6! = 720 sequences (because there are 6 files),
# which would take way too long.  Fortunately, most of those sequences
# are redundant because it only matters when the state of the victim
# child cert or CRL transitions:
#
#   * from not present to present (either present and valid or
#     present but not yet valid because the certification path isn't yet
#     complete), or
#   * from present but not yet valid to present and valid
#
# This can be expressed as four events A, B, X, Y where:
#
#   * event A happens when the victim child cert has been added but
#     its hierarchy is still incomplete
#   * event B happens when the victim child cert and its hierarchy
#     have been added
#   * event X happens when the CRL has been added but its hierarchy is
#     still incomplete
#   * event Y happens when the CRL and its hierarchy have been added
#
# Events A and X are optional (the cert/CRL can transition from not
# present to present with complete hierarchy without first going
# through present but hierarchy incomplete).  If A happens it must
# happen some time before B.  If X happens, it must happen some time
# before Y.
#
# There are 14 different event sequences that match the above rules:
#   1. ABXY
#   2. AXBY
#   3. AXYB
#   4. XABY
#   5. XAYB
#   6. XYAB
#   7. ABY
#   8. AYB
#   9. YAB
#   10. BXY
#   11. XBY
#   12. XYB
#   13. BY
#   14. YB

@SETUP_ENVIRONMENT@

t4s_setup

u=${TESTS_TOP_SRCDIR}/tests/util.sh
. "${u}" || t4s_bailout "unable to load ${u}"
pecho() { printf %s\\n "$*"; }

cd "${TESTS_BUILDDIR}" || t4s_bailout "unable to cd to ${TESTS_BUILDDIR}"

# print arguments with duplicates removed (first instance preserved,
# no sorting)
uniquify() {
    printf '%s ' $(
        printf %s\\n "$@" | grep -v '^[[:space:]]*$' | awk '!x[$1]++{print$1}'
    )
    printf \\n
}

# files to add to achieve event A
event_A() {
    printf %s\\n ta.cer ca-victimchild.cer
}
# files to add to achieve event B
event_B() {
    printf %s\\n ta.cer ca-victim.cer ca-victimchild.cer
}
# files to add to achieve event X
event_X() {
    printf %s\\n ta.cer ca-evil.cer ca-fakevictim.crl
}
# files to add to achieve event Y
event_Y() {
    printf %s\\n ta.cer ca-evil.cer ca-fakevictim.cer ca-fakevictim.crl
}

expected_files=$(uniquify $(event_B; event_Y) )
t4s_log "expected_files=${expected_files}"

n=0
while IFS= read -r event_sequence; do
    n=$((n+1))
    files_to_add=
    for e in ${event_sequence}; do
        files_to_add=$(uniquify ${files_to_add} $(event_"${e}") )
    done
    t4s_log "files_to_add=${files_to_add}"

    # if the evil CRL hierarchy is completely added before the victim
    # child cert is added, then this test will fail.  stated another
    # way, if any part of the evil CRL hierarchy is added after the
    # victim child cert then this will pass.
    xfail=true
    all=$(printf " %s " ${files_to_add})
    t4s_log "all=${all}"
    # this only contains the objects added after ca-victim.cer
    after_victim=${all##* ca-victimchild.cer }
    t4s_log "after_victim=${after_victim}"
    for f in $(event_Y); do
        case ${after_victim} in
            *" ${f} "*) unset xfail; break;;
        esac
    done

    t4s_testcase ${xfail+"--xfail=see issue #52"} \
        "event sequence: $(printf %s ${event_sequence}) files: ${files_to_add}" \
        '
            reset_add_check \
                "${0##*/}".cache/"${n}" \
                "${files_to_add}" \
                "${expected_files}"
        '
done <<EOF
A B X Y
A X B Y
A X Y B
X A B Y
X A Y B
X Y A B
A B Y
A Y B
Y A B
B X Y
X B Y
X Y B
B Y
Y B
EOF

t4s_done
